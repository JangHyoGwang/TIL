# 1로 만들기

## 문제

- 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
 2. X가 2로 나누어 떨어지면, 2로 나눈다.
 3. 1을 뺀다.
- 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력
- 첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

## 풀이

- 3가지 연산을 이용해서 x를 1로 만드는 방법중에 가장 적은 횟수로 만들 수 있는 방법을 찾는 문제
  - 쉽게 생각하면 가장 큰 수로 나누면, 가장 적게 연산을 사용할 수 있다(?)
  - x = 10
  - 3으로 나눠보고, 2로 나눠보고 1을 뺀다.
  ```
  10 -> 5 -> 4 -> 2 -> 1(4번 연산)
  10 -> 9 -> 3 -> 1(3번 연산)
  ```

- 즉, 가장 큰수로 먼저 나눈다고 해서 정답을 구할수는 없다.

- 동적계획법
  - 1에서 1을 만들 수 있는 연산의 최소 횟수
  - 2에서 1을 만들 수 있는 연산의 최소 횟수
  - 3에서 1을 만들 수 있는 연산의 최소 횟수
  - ... 
  - 10에서 1을 만들 수 있는 연산의 최소 횟수

- i에 가능한 경우
  - i가 3으로 나누어 떨어지는경우
  - i가 2로 나누어 떨어지는 경우
  - i에서 1을  빼는 경우
  - 3가지 중에서 가장 작은 값이 들어가면 됩니다. 

- 예를 들면

|0|1|2|3|4|5|6|7|8|9|10|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|1|1|2|3|2|3|3|2|3|

- 동적계획법이 가능하려면
  - 모든 수에서 1로 만드는데 필요한 최소 횟수를 구하는 방법이 동일해야 합니다. 
    - d[i] = i를 1로 만드는데 필요한 최소 연산의 횟수
      - d[i] = min( d[i//3] + 1, d[i//2] + 1, d[i-1] + 1 )
  - 또한 지역 최적화가 가능해야 합니다. 
    - 10에 1로 가는 방법이 9를 통해 3으로 가는 방법이 최선 이라면
    - 9에서 1로 가는 방법도 3을 통해 가는 방법이 최선이어야 합니다. 

``` Python
n = int(input())
d = [0] * (1000000 + 1)
d[2] = 1
for i in range(3, n + 1):
  d[i] = d[i - 1] + 1
  if i % 2 == 0 and d[i] > d[i//2] + 1: d[i] = d[i//2] + 1
  if i % 3 == 0 and d[i] > d[i//3] + 1: d[i] = d[i//3] + 1
print(d[n])
```
