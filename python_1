# jupyter
- 주로 `데이터 분석`, `머신러닝`에서 주로 많이 사용
- 일반적인 개발 환경과는 약간 차이가 있습니다. 
- 파이썬의 소스파일은 확장자를 `*.py`를 사용합니다. 
  - 주피터 같은 경우는 `*.ipynb`를 사용합니다. 
  - 주피터는 파일 이라고 하지 않고, `노트북`이라고 표현을 합니다. 
  - `*.py`과 `*.ipynb` 파일은 호환되지 않습니다. 
  - 주피터 이전에 사용했던 개발환경이 `IPython` 이었습니다. 
  - `IPython` + `NoteBook`을 합쳐서 `ipynb`라고 합니다. 

- 일반적인 개발환경에서는 소스파일을 읽어들여서 한 번에 실행
  - 주피터는 `셀` 혹은 `블록`단위로 코드를 작성하고 실행



1 + 1

2 + 2

# 파이썬 인터프리터의 동작 방식
- 컴파일 과정이 없습니다. 
- REPL(Read, Evaluation, Print, Loop)
  - Read: 입력된 명령어를 읽고
    - 중간에서 해석(문자 -> 숫자)
  - Evaluation: 명령어를 실행
  - Print: 실행된 결과를 돌려줍니다. 
  - Loop: 이 과정을 계속 반복
- 주피터는 일반적인 파이썬의 실행환경과 인터프리터의 실행환경의 중간적인 환경을 제공

# 타입
- 문자열, 숫자
  - 파이썬은 문자 타입은 없습니다. 
  - 파이썬에서 모든 문자는 문자열 타입으로 표현
  - char라는 타입이 없고, str 타입만 존재

## 문자열
- ', " 둘 중에 하나를 사용
  - 차이는 없습니다.
  - 문자열 이스케이프도 동일

- 수업시간에 다루지 못하는 문자열에 대한 내용은 아래의 내용을 참조하시면 됩니다. 
  - [문자열 참조](https://docs.python.org/ko/3/library/stdtypes.html#text-sequence-type-str)

'hello world'

"hello world"

파이썬은 한 줄에 하나의 명령어가 원칙 입니다. 

# 여러줄에 걸쳐서 문자를 표현할 수 없습니다. 
'hello
world'

# 파이썬은 멀티라인 문자열을 지원합니다. 
'''
hello
world
'''

# 하나의 문자열, 하나의 명령어를 여러줄에 나눠서 작성하고 싶다면
'hello \
world'

# 여러개의 명령을 한 줄에 작성할 수 없습니다. 
print('hello') print('world')

# 세미콜론을 이용하면 여러개의 명령어를 작성할 수 있습니다. 
print('hello'); print('world')

## 문자열 메서드
- split()
- replace()
- strip()
- join()
- format()


split과 같은 경우는 `화이트 스페이스`를 기준으로 문자열을 분할
  - 화이트 스페이스는 문장 내에서 단어를 구분하는 기준
  - 공백, 탭, 뉴라인
  - 공백을 기준으로 분할

'Lorem ipsum dolor sit amet'.split()

# 정의된 파라미터의 순서에 맞춰서 전달
'Lorem/ipsum/dolor/sit/amet'.split('/')

# 어떤 파라미터의 입력인지 지정해도 됩니다.
# 파라미터의 순서를 고려하지 않아도 됩니다. 
'Lorem/ipsum/dolor/sit/amet'.split(maxsplit=10, sep='/')

replace는 조건에 맞는 문자열을 치환하는 기능
- 바꾸기 기능과 동일한 기능

'Lorem ipsum dolor sit amet'.replace('Lorem', 'A')

strip은 문자열 앞, 뒤에 존재하는 화이트 스페이스를 모두 제거

# 문자열 중간에 들어가 있는 화이트 스페이는 제거되지 않습니다. 
'     \n ABCD\nEFGH        \n '.strip()

# 문자열의 왼쪽에 있는 화이트 스페이만 제거
'     \n ABCD\nEFGH        \n '.lstrip()

# 문자열의 오른쪽에 있는 화이트 스페이스만 제거
'     \n ABCD\nEFGH        \n '.rstrip()

join은 여러개의 문자열을 하나의 문자열로 만들어 줍니다. 

''.join(['c', 'java', 'python'])

' '.join(['c', 'java', 'python'])

format은 format string 기능입니다. 
- format() 함수를 이용하는 방법
- f-string을 사용하는 방법

'The sum of 1 + 2 is 3'

# format 함수를 이용하는 방법
'The sum of 1 + 2 is {}'.format(1 + 2)

'The sum of {2} + {0} is {1}'.format(1, 2, 1 + 2)

# f-string을 이용하는 방법
f'The sum of 1 + 2 is {1+2}'

format 활용

# 실수를 표현하는 경우(자릿수 포함)
'{:.02f}'.format(1)

# 자릿수를 1000단위로 끊어서 표현
'{:,}'.format(2398475928374582798345)

## 숫자
- float, int, bool, complex
- 파이썬에서의 실수는 `float` 하나만 지원 
- 파이썬의 숫자의 크기가 정해져 있지 않습니다. 
  - 얼마든지 큰 수를 표현할 수 있습니다. 
  - 수가 커지게 되면, 속도가 매우 느려지게 때문에, 주의
- 실제 문제를 풀때는 실수를 사용할 일은 거의 없습니다. 
  - 거의 모든 언어가 가지고 있는 한계
  - 실수는 정확한 연산이 안된다고 보면 되기 때문에 
  - 만약에 실수를 사용할 일이 있다면, 근사해서 사용을 해야 합니다. 

209834750928340958029834095820934850928340958209384059820934850928309485092834095820934850928340958

bool 타입은 다음과 같은 특징이 있습니다. 

type(True)

# True는 1과 같습니다. 
True == 1

# False는 0과 같습니다. 
False == 0

True + True + True

# 연산자
- 사칙연산(+, -, *, /)
- 지수(**), 몫연산(//), 나머지(%)
- 부호(-)
- 불리언 연산자(and, or, not)
- 비교연산자
  - ==, !=, >, <, >=, <=

- 우선순위 
```
() > ** > - > *, /, //, % > +, -
```

기본적인 연산자들은 거의 모든 언어가 공통적으로 제공하는 기능

print( 10 ** 2 )
print( 10 / 3 )
print( 10 // 3 )
print( 10 % 3 )

부호연산

- - - 3

## 타입변환
- 비교적 자유롭게 타입을 다른 타입으로 변환할 수 있습니다. 
  - str(), int(), float(), bool()
  - str(x): 정수, 실수를 문자로 변환
  - int(x): 실수, 문자열을 정수로 변환
  - float(x): 정수, 문자열을 실수로 변환
  - bool(x): 모든 타입을 전부 참이나 거짓으로 변환

문자열을 정수나 실수로 변환

int('210394')

int('1092348a09234')

불리언 변환은 규칙이 있습니다. 
- 무조건 True 혹은 False로 변환이 됩니다. 
  - 빈 객체, 0이면 무조건 False가 됩니다. 
  - 그 외에는 전부 참이 됩니다. 

bool('')

bool(0)

bool('거짓')

논리연산 
- &&, ||, !과 같은 기호를 사용하지 않습니다. 
  - and, or, not

- 우선순위
```
  not > and > or
```

1 == 1 or 1 == 2 and 1 == 3

(1 == 1 or 1 == 2) and 1 == 3

# 변수
- 파이썬은 변수의 선언이 없습니다. 
  - 선언과 정의가 동시에 이뤄진다고 이해
  - 동적 바인딩

## 동적 바인딩

a = 10

hex(id(a))

파이썬은 변수의 값이 동일하면, 굳이 새로운 메모리에 동일한 값을 또 만들지 않습니다. 

a = 10
b = 10

print( hex(id(a)) )
print( hex(id(b)) )

b = 20

print( hex(id(a)) )
print( hex(id(b)) )

a, b = b, a

print(a, b)

# 파이썬의 기본적인 자료구조
- 선형자료구조
  - 시퀀스 타입
  - list, tuple, range
  - list가 다른언의 배열과 같은 역할
  - str도 시퀀스형의 하나입니다. 
  - [참조](https://docs.python.org/ko/3/library/stdtypes.html#sequence-types-list-tuple-range)

- 매핑 형
  - dict

- 집합 형
  - set

## 튜플
- 불가변형 타입의 대표적인 시퀀스 타입
  - 원소의 값이 변하지 않음을 의미
  - 바꿀 수 없다는 뜻입니다. 
  - str은 튜플의 한 종류(튜플을 상속받아서 정의)

# 빈 튜플을 생성
arr = ()
type(arr)

# 빈 튜플을 생성하는 또 다른 방법
arr = tuple()
type(arr)

튜플을 다룰 때 주의해야 할 점
- 연산자의 우선순위를 표현: ()
- 튜플을 표현하는 경우에도: ()

type( (10) )

# 기본적으로 원소가 1개 이상이면, 튜플로 인식
type( (10, 20) )

# 만약에 원소가 하나인 튜플을 표현하고 싶다면
type( (10,) )

# 기본값이 있는 튜플을 생성하는 방법
arr = (1, 2, 3, 4, 5)
arr

arr = tuple( (1,) )
arr

### 공통 연산자
- 튜플과 리스트 모두 동일하게 사용할 수 있다. 

arr = (10, 20, 30)

print( 10 in arr )
print( 1 in arr )

print( 10 not in arr )
print( 1 not in arr )

문자열과 튜플과 같은 시퀀스 타입에서는 덧셈과 곱셈 연산이 가능합니다. 

'hello' + 'world'

# 덧셈은 피연산자의 타입이 같아야만 합니다. 
# 인터프리터는 아래와 같은 명령을 이해할 수 없습니다. 
'1' + 1

# 두 튜플을 하나도 합친 새로운 튜플을 돌려줍니다. 
arr + (40, 50, 60)

곱셈과 같은 경우는 times(반복)의 의미로 해석

'a' * 5

arr * 5

5 * arr

인덱싱
- 튜플의 인덱스는 자동으로 생성
- 0부터 순차적으로 1씩 증가하면서 번호가 매겨집니다. 
- 파이썬은 음수 인덱싱이 가능
  - 원소의 마지막부터 자동으로 번호가 매겨집니다. 
  - -1 부터 -1씩 감소하면서 번호가 매겨집니다. 

arr[0]

arr[-1]

# 인덱스의 범위를 벗어나면 예외가 발생
arr[5]

슬라이스
- 정말 많이 사용되는 기능
- 파이썬의 슬라이스는 의외로 빠릅니다. 
  - 특정 범위내의 원소를 잘라오는 기능
  - 멀티 인덱싱 용도로 많이 사용이 됩니다. 

arr = (10, 20, 30, 40, 50)
print( arr )

# 마지막 인덱스의 원소는 포함되지 않습니다. 
arr[1:4]

슬라이스를 사용하는 여러가지 형태

# 전체 원소를 전부 선택
print( arr[0:5] )

# 슬라이스를 하는 경우에만 범위를 확인하지 않습니다. 
print( arr[0:1000000])

# 시작위치와 끝나는 위치를 정하지 않는 경우
print( arr[:] )

# 끝나는 위치만 정하는 경우, 첫 번째 원소부터
print( arr[:4] )

# 시작 위치만 정하는 경우, 마지막 원소까지
print( arr[1:])

# k의 기본값은 1이고, 생략 가능한 형태
print( arr[0:5:1] )
print( arr[::1] )

# 짝수번째 인덱스의 원소만 선택
print( arr[1::2] )

# 홀수번째 인덱스의 원소만 선택
print( arr[::2] )

# 원소를 뒤에서부터 선택하는 것도 가능(reverse)
print( arr[-1:-6:-1])
print( arr[::-1] )

### 가변 연산자
- 튜플에서는 가변 연산자를 사용할 수 없습니다. 

## 리스트
- 파이썬에서 가장 많이 사용되는 자료형
- 다른 언어에서는 배열 이라고 합니다. 
- 파이썬의 리스트는 `연결 리스트`로 구현되어 있습니다. 
  - 파이썬은 연결 리스트를 구현할 필요가 없습니다. 

# 빈 리스트를 만드는 방법
arr = []
type(arr)

arr = list()
type(arr)

arr = [10, 20, 30, 40, 50]
arr

### 공통 연산자
- 튜플과 마찬가지로 동일하게 사용할 수 있습니다. 

### 가변 연산자

append Vs. extend

# 원소 하나를 추가하는 경우
# 리스트의 마지막에 원소를 추가합니다.
print(arr)
arr.append(60)
arr

# 리스트의 마지막에 리스트를 추가하는 경우
print( arr )
arr.extend( [70, 80, 90] )
arr

# extend는 아래의 명령와 동일한 일을 합니다. 
print( arr )
# arr = arr + [100, 110]
arr += [100, 110]
arr

# 리스트의 원하는 위치에 원소를 추가(삽입)
print( arr )
arr.insert(5, 55)
arr

# pop은 스택과 큐를 구현할 때 주로 사용
# 기본적으로는, 리스트의 가장 마지막 원소를 꺼내옵니다. 
print(arr)
arr.pop()

# 리스트 내에서 원하는 원소를 꺼내올 수 있습니다. 
arr.pop(2)

## 얕은 복사(주소 복사) Vs. 깊은 복사(값 복사)

arr

# 새로운 메모리로 복사
other = arr

print( hex(id(other)))
print( hex(id(arr)))

# copy를 이용해서 새로운 메모리에 복사
other = arr.copy()

print( hex(id(other)))
print( hex(id(arr)))

# 슬라이스를 이용해도 동일한 결과를 얻을 수 있습니다. 
other = arr[:]

print( hex(id(other)))
print( hex(id(arr)))

그런데 왜 `얕은복사`라는 표현을 사용할까? 
- 분명히 값이 복사된게 맞는데
- 완벽하게 깊은 복사가 되지는 않습니다. 

# 파이썬에서의 다차원 리스트는 리스트를 리스트를 원소로 갖는 형태
arr2D = [
  [1, 2, 3], [4, 5, 6], [7, 8, 9]
]

arr2D

# 파이썬의 리스트는 타입이 모두 동일할 필요가 없습니다. 
arr = [1, 'string', [1, 2, 3]]
arr

arr2D[0][0]

other = arr2D[:]

print( hex(id(other)))
print( hex(id(arr2D)))
print( hex(id(other[0])))
print( hex(id(arr2D[0])))

파이썬에서의 깊은 복사는 어떻게 할 수 있는가? 
- deepcopy를 이용하면 완벽하게 깊은복사를 할 수 있습니다. 
- 그렇지 않으면, 값의 일부는 복사가 되고, 일부는 복사가 안될 수 있습니다. 

import copy
other = copy.deepcopy(arr2D)

print( hex(id(other)))
print( hex(id(arr2D)))
print( hex(id(other[0])))
print( hex(id(arr2D[0])))

