<DBMS:통합 데이터:최소한의 중복만을 허용, 저장데이터: 컴퓨터가 접근할 수 있는 컴퓨터에 저장된 데이터를 의미, 운영데이터: 지속적으로 변화되며 시스템이 사용하는 데이터, 공용데이터:공동으로 사용되는 데이터를 의미 database:한 조직에 필요한 정보를 여러 응용 시스템에서 공용할 수 있도록 논리적으로 연관된 데이터를 모으고, 중복되는 데이터를 최소화하여 구조적으로 통합/저장해 놓은 것이다. 관계형 데이터베이스: 모든 데이터를 2차원 테이블 형태로 표현, 테이블 사이의 비즈니스적 관계를 도출하는 구조를 가진 데이터베이스 유형, 데이터의 중복을 최소화 할 수 있으며, 업무 변화에 대한 적응령이 우수함>
<JDBC(Java DataBase Connectivity): 자바 언어에서 database에 접근할 수 있게 해주는 프로그래밍 API)
<DriverManager클래스:데이터 원본에 JDBC 드라이버를 통하여 커넥션을 만드는 역할을 한다. Class.forName() 메소드를 통해서 생성되는데, 이 메소드는 인터페이스 드라이버를 구현하는 작업이다. Class.forName("oracle.jdbc.driver.OracleDriver")처럼 특정 클래스를 로딩하면 자동으로 객체가 생성되고 DriverManager등록된다. 드라이버 클래스 찾지 못할 경우 forName() 메소드는 ClassNotFoundException 예외를 발생시키므로, 반드시 예외처리를 해야한다. 드라이버 클래스들은 로드될 때 자신의 인스턴스를 생성하고, 자동적으로 DriverManager 클래스 메소드 호출하여 인스턴스를 등록한다. DriverManager클래스의 모든 메소드는 static이기 때문에 반드시 객체를 생성시킬 필요가 없다. DriverManager클래스는 Connection 인터페이스의 구현 객체를 생성하는데 getConnection()메소드를 사용한다.>
<Connection: 특정 데이터 원본에 대한 커넥션은 Connection 인터페이스가 구현된 클래스의 객체로 표현된다. 어떤 sql 문장을 실행시키기 전에 우선 connection 객체가 있어야 한다. Connection 객체는 특정 데이터 원본과 연결된 커넥션을 나타내고, 특정한 sql 문장을 정의하고 실행시킬 수 있는 Statement 객체를 생성할 때 Connection 객체를 사용한다. Connection 객체는 데이터베이스에 대한 데이터인 메타데이터에 관한 정보를 데이터 원본에 질의하는데 사용한다 이 때, 사용 가능한 테이블의 이름, 특정 테이블의 열에 정보등이 포함된다.
<Statement: Statement인터페이스는 Connection객체를 통해 프로그램에 리턴되는 객체에 의해 구현되는 일종의 메소드 집합을 정의한다. Statement객체는 Statement 인터페이스를 구현한 객체로, 항상 인수가 없는 Connection 클래스의 CreateStatement()메소드를 호출함으로써 얻어진다. Statement객체를 생성하면 Statement객체의 exequteQuery()메소드를 호출하여 sql 질의를 실행시킬 수 있다. 메소드의 인수로는 sql 질의 문장을 담은 String 객체를 전달한다. Statement 객체는 단순한 질의문을 사용할 경우에 좋다.
<PreparedStatement인터페이스는 Connection객체의 prepareStatement()메소드를 사용해서 객체를 생성한다. PreparedStatement객체는 sql문장이 미리 컴파일 되고, 실행시간동안 인수 값을 위한 공간을 확보할 수 있다는 점에서 Statement객체와 다르다. PreparedStatement 객체는 동일한 질의문을 특정 값만 바꾸어서 여러번 실행해야 할 때, 많은 데이터를 다루기 때문에 질의문을 정리해야 할 필요가 있을때, 인수가 많아서 질의문을 정리해야 할 필요가 있을때 사용하면 유용하다. 또한, Statement 객체의 sql은 실행될 때 매번 서버에서 분석되어야 하는 반면 PreparedStatement객체는 한번 분석되면 재사용이 용이하다는 장점을 가지고 있다. PreparedStatement인터페이스는 각각의 인수에 대해 위치홀더(placeholder)를 사용하여 sql 문장을 정의할 수 있다. 위치홀더는 물음표('?')로 표현된다. 위치홀더는 sql문장에 나타나는 토큰인데, 이것은 sql문장이 실행되기 전애 실제 값으로 대체된다. 이러한 방법을 이용하면 특정 값으로 문자열을 연결하는 방법보다 훨씬 쉽게 sql문장을 만들 수 있다. 장점:1.동일한 질의문을 특정값만 바꿔서 여러번 실행해야 할 때, 많은 데이터를 다루기 떄문에 질의문을 정리해야할 필요가 있을때, 인수가 만하서 질의문을 정리해야 할 필요가 있을때 좋다. 2. 미리 컴파일 되기 때문에 쿼리의 수행속도가 Statement객체에 비해 빠르다. 3. Statement객체는 쿼리 실행시 작은 땀옴표(')가 들어있으면 작은 따옴표를 두개(")로 표시해야한다. 그러나 PreparedStatement 객체는 작은 따옴표의 문제를 쿼리 실행시 자동으로 처리하므로 신경 쓸 필요가 없다.>
<ResultSet:sql문에서 SELECT문을 사용한 질의의 경우 성공 시 결과물로 ResultSet을 반환한다. ResultSet은 SQL질의이 의해 생성된 테이블을 담고 있다. 또한 ResultSet 객체는 커서라고 불리는 것을 가지고 있는데, 그것으로 ResultSet에서 특정 행에 대한 참조를 조작할 수 있다. 커서는 초기에 첫번째 행의 직전을 가리키도록 되어 있는데, ResultSet객체의 next() 메소드를 사용하면 다음 위치로 커서를 옮길 수 있다.
ResultSet에서 행을 처리하는데 반복문을 사용하며 next() 메소드가 유요한 행이 있으면 true 없으면, false를 리턴하는 것을 이용하여 while으로 제어할 수 있다. ResultSet객체에서 현재 행에서 필드명 혹은 레코드셋에서의 위치를 통해서 어떤 필드의 값을 가져올 수 있는데 이때 getXxxx()매소드를 제공한다. 해당 필드의 데이터 타입이 문자열이면 getString()이 되고 해당 필드의 데이터 타입이 int면 getInt()가 된다.
<commit/rollback:기본적으로 Connection객체에 setAutoCommit(boolean auntoCommit)이란 메소드가 있는데 기본값이 true로 설정되어 있다. 기본적으로 JSP는 오토커밋이다. 그러나 트랜잭션을 처리할때는 오토머밋이 일어나서 자동으로 commit을 사용하면 안된다. 여러개의 쿼리 문장이 하나의 작업으로 수행되어야 하기 때문에 jsp의 오토커밋이 자동으로 작동되지 못하게 해야한다. 오토커밋이 자동으로 작동되지 못하게 하려면 setAutoCommit(false);으로 지정해야 한다. COMMIT(트랜잭션 작업이 정상 완료되면 변경 내용을 영구히 저장), ROLLBACK(트랜잭션 작업을 모두 취소하고 최근 commit 시점으로 이동)>
<자원 해제: Connection을 close()해주지 않으면 사용하지 않는 연결이 유지됨, DB자원을 낭비하게 됨. 생성된 객체의 역순으로 메모리를 해제함, 본래 커넥션이 해제될 때 나머지는 자동으로 해제되는게 정상이라고는 하는데 그 과정에서 예외가 발생할 경우 자동 해제가 되지 않아 문제가 발생하는 경우가 있다고 합니다. 따라서 명시적으로 자원을 해제해주는 것이 좋은 방법입니다. 해제 순서는 만든 순서의 역순입니다.
<싱글톤 패턴>public static JDBCTemplate getDriverLoad() {
		if(instance == null) {
			instance = new JDBCTemplate();
		}
		return instance;
	}
싱글톤 패턴은 객체의 인스턴스가 오직1개만 생성되는 패턴을 의미한다. 사용하는 이유는 최초 한번의 new 연산자를 통해서 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근할 때 메모리 낭비를 방지할 수 있다. 뿐만 아니라 이미 생성된 인스턴스를 활용하니 속도 측면에서도 이점이 있다고 볼 수 있다. 또다른 이점은 다른 클래스 간에 데이터 공유가 쉽다는 것이다. 싱글톤 인스턴스가 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있다.

