캡슐화 : 추상화를 통해 정리된 데이터들과 기능을 하나로 묶어 관리하는 기법으로, 데이터의 접근 제한을 원칙으로 한다.
원칙 : 클래스의 멤버 변수에 대한 접근권한은 private을 원칙으로 한다.
메소드 : 클래스 멤버 변수에 대한 연산처리를 목적으로 하는 메소드를 클래스 내부에 작성하고 클래스밖에서 접근할 수 있도록 public설정
static : 같은 타입의 여러객체가 공유할 필드에 사용하며, 프로그램 start시에 정적 메모리영역에 자동할당되는 멤버에 적용
메소드란 : 수학의 함수와 비슷하며 호출을 통해 사용된다. 호출 시 전달값은 있거나 없을 수 있다. 함수가 호출되면 내부에 작성된 연산을 수행하게 되며 연산 후 결과값/반환값은 있거나 없을 수있음
오버로딩 : 메소드 이름 동일, 매개변수 선언부 달라아 함(타입, 개수, 순서), 매개변수명 무상관, 리턴타입 무상관
생성자 : 객체를 생성할 때 항상 실행되는 것으로, 메소드 중에서 맨 처음 실행되는 메소드 / 객체의 초기화란 클래스가 객체를 생성/호출하였을 때, 객채의 필드를 초기화하거나 메소드를 호출해서 
객체를 사용할 준비를 하는 것으로 일련의 준비단계
생성자 규칙 : 클래스에 반드시 생성자 존재, 인스턴스 생성시 딱 한번 호출, 클래스 이름과 동일한 이름을 가진 메소드, 노리턴
생성자종류: 객체를 호출할 떄 클래스는 생성자를 통해 객체를 초기화, 구현 방법에 따라 기본 생성자, 매개변수가 있는 생성자
-> 기본 생성자 : 작성하지 않은 경우, 클래스 사용시 JVM이 기본 생성자 자동 생성
-> 매개변수 있는 생성자 : 객체 생성시 전달 받은 값으로 객체를 초기화 하기 위해 사용, 매개변수 있는 생성자 작성시 JVM이 기본 생성자 자동 생성X, 상속 사용시 반드시 기본 생성자 작성, 오버로딩을 이용하여 작성
상속 : 다른 클래스가 가지고 있는 멤버들을 새로 작성할 클래스에 직접 만들지 않고, 상속을 받음으로써 새 클래스가 자신의 멤버처럼 사용할 수 있는 기능, 목적 : 클래스의 재사용, 
연관된 일련의 클래스들에 대해 공통적인 규약을 정의
장점 : 보다 적은 양의 코드로 새로운 클래스 작성 가능, 코드의 중복을 제거하여 프로그램의 생산성과 유지보수, 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
super: 부모 객체의 생성자 호출 메소드임 후손 생성자에 기본적으로 부모생성자가 포함되어 있으며 명시적으로 부모객체의 생성자를 호출할 부모 생성자가 가장 먼저 실행이 
되어야 하기 때문에 반드시 첫 줄에만 작성가능함 | 매개변수가 있는 부모 생성자 호출은 super를 넣으면 됨
상속 특징: 부모 클래스 생성자 상속 안됨, 하지만 자동으로 호출 | 부모의 private 멤버는 상속은 되지만 직접접근불가 | 모든 클래스는 Object 클래스의 후손
오버라이딩: 자식클래스가 상속받은 부모 메소드를 재작성하는 것을 말함 | 부모가 제공하능 기능을 후손이 일부 고쳐 사용하겠다는 의미로 자식객체를 통한 실행 시 후손것이 우선권(동적바인딩) 
| 메소드 헤드라인에 위에 반드시 Annotation 표시, 부모메소드 접근제어자 수정가능
오버라이딩 성립요건: 이름 동일, 매개변수 개수 타입 동일, 리턴 타입 동일, private메소드 오버라이딩 불가
다형성: 여러개의 형태를 갖는다는 의미, 상속을 이용한 기술로 자식 객체를 부모 클래스타입의 변수로 다룰 수 있는 기술
메소드 호출시 다형성을 이용하여 부모타입의 매개변수를 사용하면 자식타입의 객체를 바을 수 있음 ex) angryCar(new Sonate());
클래스 형변환(업캐):상속관계에 있는 부모, 자식 클래스간에 부모타입의 참조형 변수가 모든 자식타입의 객체의 주소를 받을 수 있다
다캐: 자식객체의 주소를 받은 부모 참조형 변수를 가지고 자식의 멤버를 참조해야할 경우, 후손 클래스 타입으로 참조형 변수를 형 변환해야함, 자동으로 처리되지 않기 떄문에 반드시 후손 타입을 명시해서 형 변환해야 함
instanceof : 현재 참조형 변수가 어떤 클래스 형의 객체 주소를 참고하고 있는지 확인할 떄 사용, 클래스타입이 맞으면 true, false
동적바인딩 : 컴파일시 정적바인딩된 메소드를 실행할 당시의 객체 타입을 기준으로 바인딩 되는 것을 동적 바인딩이라고 한다. 성립 요건 : 상속 관계로 이루어져 다형성이 적용된 경우에 
메소드 오버라이딩이 되어 있으면 정적으로 바인딩 된 메소드 코드보다 오버라이딩 된 메소드 코드를 우선적 수행
추상 클래스 : 몸체 없는 메소드를 포함한 클래스, 추상 클래스일 경우 클래스 선언부에 abstract 키워드 사용 | 특징 : 미완성 클래스, 자체적으로 객체 생성 불가, 일반적인 메소드, 
변수 포함 가눙, 객체 생성은 안되나 참조형 변수 type은 가능
추상 메소드 : 몸체 없는 메소드, 추상 메소드 선언부에 abstract선언 상속시 반드시 구현(오버라이딩 강제화)
인터페이스 : 상수형 필드와 추상 메소드만을 작성할 수 있는 추상클래스 변형체, 메소드의 통일성을 부여하기 위해서 추상 메소드만 따로 모아놓은것, 상속시 인터페이스 내에 정의된 
추상메소드 구현해야함 | 특징 : 모든 인터페이스의 메소드는 묵시적으로 public, abstract이다 변수는 묵시적으로 public static final->따라서 인터페이스 변수의 값 변경 시도는 컴파일시 에러 발생, 
객체 생성x 참조형반수로는 가능 장점 : 공통 기능상의 일관성 제공, 공동 작업을 위한 인터페이스 제공 | 사용목적 : 클래스와 클래스를 연결해주는 인터페이스, 사양서 역할의 인터페이스, 
다중 상속이 없는 자바에 다중 상속 지원? implements사용 
제네릭스 : jdk 1.5부터 제공되는 기능으로, 컬렉션 클래스를 이용해서 객체를 저장할때 저장할 객체(클래스타입)을 제한하는 기능, 한가지 종류의 클래스만 저장할 수 있게 해놓은기능
| 사용 이유 : 컴파일 단계에서 잘못된 타입을 사용할 수 있는 가능성 제거, 컬렉션에 저장된 여러 종류의 객체를 꺼내서 사용할 떄, 객체의 종류에 따라 매번 형변환하는 복잡한 코드 제거, 
컬렉션 람다식 스트림 nio에서 널리 사용, 제네릭 모르면 API 다큐먼트 해석이 어렵기 떄문에 학습에 제한
컬렉션: 자바에서 제공하는 자료구조 담당하는 프레임 워크, 메모리 상에서 자료를 구조적으로 처리하는 방법을 자료구조라고 함, 추가 삭제 정렬등의 기능처리가 간단하게 해결되어 자료구조적 알고리즘을 구현할 필요가 없다.
베열의 문제점 : 한번 크기를 지정하면 변경 불가, 배열에 기록된 데이터에 대한 중간 위치 추가, 삭제가 불편, 한 타입의 데이터만 저장 가능
컬렉션의 장점 : 저장하는 크기 제약 없음, 추가 삭제 정렬등의 기능처리가 간단 해결, 여러 타입을 저장 가능
list: 순서 유지, 중복저장 가능 | 자료들을 순차적으로 나열한 자료 구조, 인덱스로 관리
ArrayList: List후손 초기 저장용량은 10으로 자동 설정, 따로 지정도 가능. 저장용량을 초과한 객체들이 들어오면 자동적으로 늘어남, 고정도 가능함 동기화 노제공
set: 순서 노유지, 노중복
map : 키와 값의 쌍으로 저장, 키는 중복 저장 안됨, 값은 중복 저장 가능
오토박싱 : 기본 자료형 -> Wrapper클래스 변환 (Integer num = new Integer(3); -> Integer num = 3;)
오토언박싱 : Wrapper클래스 -> 기본자료형변환 (int n = num.intValue(); -> int n = num;)
